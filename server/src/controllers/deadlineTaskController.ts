import { Response } from 'express';
import { AuthRequest } from '../middleware/auth';
import prisma from '../config/database';
import { outlookCalendarService } from '../services/outlookCalendarService';

// Get deadline tasks for a date range
export const getDeadlineTasks = async (req: AuthRequest, res: Response) => {
  try {
    const { startDate, endDate } = req.query;

    if (!startDate || !endDate) {
      return res.status(400).json({ error: 'startDate and endDate are required' });
    }

    const deadlineTasks = await prisma.deadlineTask.findMany({
      where: {
        date: {
          gte: new Date(startDate as string),
          lte: new Date(endDate as string),
        },
      },
      include: {
        client: {
          select: {
            id: true,
            name: true,
          },
        },
        project: {
          select: {
            id: true,
            name: true,
            description: true,
            projectNumber: true,
          },
        },
      },
      orderBy: [
        { date: 'asc' },
        { slotIndex: 'asc' },
      ],
    });

    res.json(deadlineTasks);
  } catch (error) {
    console.error('Error fetching deadline tasks:', error);
    res.status(500).json({ error: 'Failed to fetch deadline tasks' });
  }
};

// Create a new deadline task
export const createDeadlineTask = async (req: AuthRequest, res: Response) => {
  try {
    const { date, slotIndex, clientId, description, deadlineType, projectId } = req.body;
    const userId = req.user?.userId;

    if (!userId) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    if (!date || slotIndex === undefined || !clientId || !deadlineType) {
      return res.status(400).json({ error: 'date, slotIndex, clientId, and deadlineType are required' });
    }

    // Check if slot is already occupied
    const existing = await prisma.deadlineTask.findUnique({
      where: {
        date_slotIndex: {
          date: new Date(date),
          slotIndex: parseInt(slotIndex),
        },
      },
    });

    if (existing) {
      return res.status(400).json({ error: 'This slot is already occupied' });
    }

    const deadlineTask = await prisma.deadlineTask.create({
      data: {
        date: new Date(date),
        slotIndex: parseInt(slotIndex),
        clientId,
        description: description || null,
        deadlineType,
        projectId: projectId || null,
        isAutoGenerated: false,
        createdBy: userId,
      },
      include: {
        client: {
          select: {
            id: true,
            name: true,
          },
        },
        project: {
          select: {
            id: true,
            name: true,
            description: true,
            projectNumber: true,
          },
        },
      },
    });

    // Sync to ALL users' Outlook calendars (non-blocking)
    outlookCalendarService.syncDeadlineTaskToAllUsers(deadlineTask.id).catch((error) => {
      console.error('[Outlook] Failed to sync deadline task to all users:', error);
    });

    res.status(201).json(deadlineTask);
  } catch (error) {
    console.error('Error creating deadline task:', error);
    res.status(500).json({ error: 'Failed to create deadline task' });
  }
};

// Update a deadline task
export const updateDeadlineTask = async (req: AuthRequest, res: Response) => {
  try {
    const { id } = req.params;
    const { date, slotIndex, clientId, description, deadlineType, projectId } = req.body;
    const userId = req.user?.userId;

    // Build update data object
    const updateData: any = {};
    if (date !== undefined) updateData.date = new Date(date);
    if (slotIndex !== undefined) updateData.slotIndex = parseInt(slotIndex);
    if (clientId !== undefined) updateData.clientId = clientId;
    if (description !== undefined) updateData.description = description;
    if (deadlineType !== undefined) updateData.deadlineType = deadlineType;
    if (projectId !== undefined) updateData.projectId = projectId;

    const deadlineTask = await prisma.deadlineTask.update({
      where: { id },
      data: updateData,
      include: {
        client: {
          select: {
            id: true,
            name: true,
          },
        },
        project: {
          select: {
            id: true,
            name: true,
            description: true,
            projectNumber: true,
          },
        },
      },
    });

    // Sync to ALL users' Outlook calendars (non-blocking)
    outlookCalendarService.syncDeadlineTaskToAllUsers(deadlineTask.id).catch((error) => {
      console.error('[Outlook] Failed to sync deadline task to all users:', error);
    });

    res.json(deadlineTask);
  } catch (error) {
    console.error('Error updating deadline task:', error);
    res.status(500).json({ error: 'Failed to update deadline task' });
  }
};

// Delete a deadline task
export const deleteDeadlineTask = async (req: AuthRequest, res: Response) => {
  try {
    const { id } = req.params;
    const userId = req.user?.userId;

    // Get task before deleting (to get createdBy for Outlook sync)
    const task = await prisma.deadlineTask.findUnique({
      where: { id },
      select: { createdBy: true }
    });

    await prisma.deadlineTask.delete({
      where: { id },
    });

    // Delete from ALL users' Outlook calendars (non-blocking)
    if (task) {
      // Outlook calendar sync
      outlookCalendarService.deleteDeadlineTaskFromAllUsers(id).catch((error) => {
        console.error('[Outlook] Failed to delete deadline task from all users:', error);
      });
    }

    res.json({ message: 'Deadline task deleted successfully' });
  } catch (error) {
    console.error('Error deleting deadline task:', error);
    res.status(500).json({ error: 'Failed to delete deadline task' });
  }
};

// Sync project due dates as deadline tasks
export const syncProjectDueDates = async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.user?.userId;

    if (!userId) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    // Get all active projects with due dates
    const projects = await prisma.project.findMany({
      where: {
        dueDate: {
          not: null,
        },
        status: 'ACTIVE',
      },
      select: {
        id: true,
        name: true,
        dueDate: true,
        clientId: true,
      },
    });

    const createdTasks = [];
    const errors = [];

    for (const project of projects) {
      if (!project.dueDate) continue;

      // Check if auto-generated deadline already exists for this project
      const existing = await prisma.deadlineTask.findFirst({
        where: {
          projectId: project.id,
          isAutoGenerated: true,
        },
      });

      if (existing) {
        // Update existing auto-generated deadline if date changed
        if (existing.date.toDateString() !== project.dueDate.toDateString()) {
          // Find an available slot on the new date
          const slot0 = await prisma.deadlineTask.findUnique({
            where: {
              date_slotIndex: {
                date: project.dueDate,
                slotIndex: 0,
              },
            },
          });

          const slot1 = await prisma.deadlineTask.findUnique({
            where: {
              date_slotIndex: {
                date: project.dueDate,
                slotIndex: 1,
              },
            },
          });

          const availableSlot = !slot0 ? 0 : !slot1 ? 1 : null;

          if (availableSlot !== null) {
            await prisma.deadlineTask.update({
              where: { id: existing.id },
              data: {
                date: project.dueDate,
                slotIndex: availableSlot,
              },
            });

            // Sync updated deadline to ALL users' Outlook calendars (non-blocking)
            outlookCalendarService.syncDeadlineTaskToAllUsers(existing.id).catch((error) => {
              console.error('[Outlook] Failed to sync updated auto-generated deadline to all users:', error);
            });
          } else {
            errors.push(`No available slot for project: ${project.name}`);
          }
        }
        continue;
      }

      // Find an available slot
      const slot0 = await prisma.deadlineTask.findUnique({
        where: {
          date_slotIndex: {
            date: project.dueDate,
            slotIndex: 0,
          },
        },
      });

      const slot1 = await prisma.deadlineTask.findUnique({
        where: {
          date_slotIndex: {
            date: project.dueDate,
            slotIndex: 1,
          },
        },
      });

      const availableSlot = !slot0 ? 0 : !slot1 ? 1 : null;

      if (availableSlot === null) {
        errors.push(`No available slot for project: ${project.name} on ${project.dueDate.toLocaleDateString()}`);
        continue;
      }

      // Create auto-generated deadline task
      const deadlineTask = await prisma.deadlineTask.create({
        data: {
          date: project.dueDate,
          slotIndex: availableSlot,
          clientId: project.clientId,
          description: project.name,
          deadlineType: 'DEADLINE',
          projectId: project.id,
          isAutoGenerated: true,
          createdBy: userId,
        },
        include: {
          client: {
            select: {
              id: true,
              name: true,
            },
          },
        },
      });

      // Sync to ALL users' Outlook calendars (non-blocking)
      outlookCalendarService.syncDeadlineTaskToAllUsers(deadlineTask.id).catch((error) => {
        console.error('[Outlook] Failed to sync auto-generated deadline task to all users:', error);
      });

      createdTasks.push(deadlineTask);
    }

    res.json({
      message: 'Project due dates synced successfully',
      created: createdTasks.length,
      errors: errors.length > 0 ? errors : undefined,
    });
  } catch (error) {
    console.error('Error syncing project due dates:', error);
    res.status(500).json({ error: 'Failed to sync project due dates' });
  }
};
